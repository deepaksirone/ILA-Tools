module main {
	instance c1 : high_low_volatile();
	instance c2 : high_low_volatile();
	
	init {
        //assume (forall (a : bv8) :: c1.IRAM[a] == c2.IRAM[a]);
        assume (forall (a: bv8) :: ((18bv8 <= a && a < 28bv8) ==> (c1.IRAM[a] == c2.IRAM[a])));
        assume (forall (a: bv8) :: ((18bv8 <= a && a < 28bv8) ==> ((c1.IRAM[a] != 0bv8) ==> (c1.IRAM[a - 10bv8] == c2.IRAM[a - 10bv8]))));
        assume (c1.IRAM[29bv8] == c2.IRAM[29bv8]);
        assume (c1.IRAM[28bv8] == c2.IRAM[28bv8]);
        assume (c1.IRAM[30bv8] == c2.IRAM[30bv8]);
	}

	next {
		next (c1);
		next (c2);
	}

	//invariant eq_mem: 
	//	(forall (a : bv8) :: c1.IRAM[a] == c2.IRAM[a]);
	invariant eq_inst:
		(forall (a : bv16) :: ((0bv16 <= a && a <= 171bv16) ==> c1.ROM[a] == c2.ROM[a]));
	invariant eq_PSW:
		(c1.PSW == c2.PSW);
	invariant eq_ACC:
		(c1.ACC == c2.ACC);
	invariant eq_PC:
		(c1.PC == c2.PC);
	invariant eq_SP:
		(c1.SP == c2.SP);
	invariant eq_state:
		(c1.current_state == c2.current_state);

	// Redundant as the all the IRAM is covered by eq_mem
    invariant eq_secret:
        (forall (a: bv8) :: ((18bv8 <= a && a < 28bv8) ==> (c1.IRAM[a] == c2.IRAM[a])));
	invariant eq_secret_data:
		(forall (a: bv8) :: ((18bv8 <= a && a < 28bv8) ==> ((c1.IRAM[a] != 0bv8) ==> (c1.IRAM[a - 10bv8] == c2.IRAM[a - 10bv8]))));
	//invariant eq_data:
	//	(forall (a: bv8) :: ((8bv8 <= a && a < 18bv8) ==> ((c1.IRAM[a] == c2.IRAM[a]))));
	invariant eq_sum:
		(c1.IRAM[29bv8] == c2.IRAM[29bv8]);
	invariant eq_i:
		(c1.IRAM[28bv8] == c2.IRAM[28bv8]);
	invariant eq_n:
		(c1.IRAM[30bv8] == c2.IRAM[30bv8]);


	control {
		v = induction;
		check;
		print_results;
		v.print_cex(c1.PC, c2.PC, c1.current_state, c2.current_state);
	}
}
